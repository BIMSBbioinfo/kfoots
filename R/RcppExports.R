# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Forward-backward algorithm
#'
#' Forward-backward algorithm using the scaling technique.
#' That's more stable (and maybe even faster) than the method with the logarithm.
#' Warning: this function overwrites the lliks matrix. This is probably a bad idea
#' because normally in the last loop you want to use the same matrix
#' for forward_backward and viterbi. I might change that in the future.
#' @param initP vector of initial probabilities
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @return a list with the following arguments:
#'	\item{posteriors}{posterior probability of being in a certain state for a certain datapoint}
#'	\item{tot_llik}{total log-likelihood of the data given the hmm model}
#'	\item{new_trans}{update for the transition probabilities (it is already normalized)}
#' @export
forward_backward <- function(initP, trans, lliks, seqlens, posteriors = NULL, nthreads = 1L) {
    .Call('kfoots_forward_backward', PACKAGE = 'kfoots', initP, trans, lliks, seqlens, posteriors, nthreads)
}

#' Viterbi algorithm
#'
#' Standard viterbi algorithm in the log space
#' @param initP vector of initial probabilities
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @return a list with the following arguments:
#'	\item{vpath}{viterbi path}
#'	\item{vllik}{log-likelihood of the viterbi path}
#' @export
viterbi <- function(initP, trans, lliks, seqlens) {
    .Call('kfoots_viterbi', PACKAGE = 'kfoots', initP, trans, lliks, seqlens)
}

orderColumns <- function(mat) {
    .Call('kfoots_orderColumns', PACKAGE = 'kfoots', mat)
}

llik2posteriors <- function(lliks, lmixcoeff, posteriors = NULL, nthreads = 1L) {
    .Call('kfoots_llik2posteriors', PACKAGE = 'kfoots', lliks, lmixcoeff, posteriors, nthreads)
}

#' Group unique values of a vector
#'
#' @param v a vector of integers. If they are not integers they will be
#' 	casted to integers.
#' @return a list with the following items:
#'		\item{values}{unique and sorted values of \code{v}}
#'		\item{map}{a vector such that \code{v[i] = values[map[i]+1]} for every i}
#'	@export
mapToUnique <- function(values) {
    .Call('kfoots_mapToUnique', PACKAGE = 'kfoots', values)
}

getMultinomConst <- function(counts, nthreads = 1L) {
    .Call('kfoots_getMultinomConst', PACKAGE = 'kfoots', counts, nthreads)
}

sumAt <- function(values, map, size, zeroIdx = FALSE) {
    .Call('kfoots_sumAt', PACKAGE = 'kfoots', values, map, size, zeroIdx)
}

colSumsInt <- function(nums, nthreads = 1L) {
    .Call('kfoots_colSumsInt', PACKAGE = 'kfoots', nums, nthreads)
}

colSumsDouble <- function(nums, nthreads = 1L) {
    .Call('kfoots_colSumsDouble', PACKAGE = 'kfoots', nums, nthreads)
}

nbinomLoglik <- function(counts, mu, r, nthreads = 1L) {
    .Call('kfoots_nbinomLoglik', PACKAGE = 'kfoots', counts, mu, r, nthreads)
}

optimFun <- function(counts, mu, r, posteriors, nthreads = 1L) {
    .Call('kfoots_optimFun', PACKAGE = 'kfoots', counts, mu, r, posteriors, nthreads)
}

fitMultinom <- function(counts, posteriors, nthreads = 1L) {
    .Call('kfoots_fitMultinom', PACKAGE = 'kfoots', counts, posteriors, nthreads)
}

lLik <- function(counts, model, ucs = NULL, mConst = NULL, nthreads = 1L) {
    .Call('kfoots_lLik', PACKAGE = 'kfoots', counts, model, ucs, mConst, nthreads)
}

lLikMat <- function(counts, models, ucs = NULL, mConst = NULL, lliks = NULL, nthreads = 1L) {
    .Call('kfoots_lLikMat', PACKAGE = 'kfoots', counts, models, ucs, mConst, lliks, nthreads)
}

