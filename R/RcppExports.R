# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Forward-backward algorithm
#'
#' Forward-backward algorithm using the scaling technique.
#' That's more stable (and maybe even faster) than the method with the logarithm.
#' Warning: this function overwrites the lliks matrix. This is probably a bad idea
#' because normally in the last loop you want to use the same matrix
#' for forward_backward and viterbi. I might change that in the future.
#' @param initP vector of initial probabilities
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @return a list with the following arguments:
#'	\item{posteriors}{posterior probability of being in a certain state for a certain datapoint}
#'	\item{tot_llik}{total log-likelihood of the data given the hmm model}
#'	\item{new_trans}{update for the transition probabilities (it is already normalized)}
#' @export
forward_backward <- function(initP, trans, lliks, seqlens, posteriors, nthreads = 1L) {
    .Call('kfoots_forward_backward', PACKAGE = 'kfoots', initP, trans, lliks, seqlens, posteriors, nthreads)
}

#' Viterbi algorithm
#'
#' Standard viterbi algorithm in the log space
#' @param initP vector of initial probabilities
#' @param trans transition matrix (rows are previous state, columns are next state)
#' @param lliks matrix with emission probabilities for each datapoint and each state.
#' Columns are datapoints and rows are states.
#' @param seqlens length of each subsequence of datapoints (set this to ncol(lliks)
#' if there is only one sequence).
#' @return a list with the following arguments:
#'	\item{vpath}{viterbi path}
#'	\item{vllik}{log-likelihood of the viterbi path}
#' @export
viterbi <- function(initP, trans, lliks, seqlens) {
    .Call('kfoots_viterbi', PACKAGE = 'kfoots', initP, trans, lliks, seqlens)
}

orderColumns <- function(mat) {
    .Call('kfoots_orderColumns', PACKAGE = 'kfoots', mat)
}

llik2posteriors <- function(lliks, mix_coeff, posteriors, nthreads = 1L) {
    .Call('kfoots_llik2posteriors', PACKAGE = 'kfoots', lliks, mix_coeff, posteriors, nthreads)
}

#' Group unique values of a vector
#'
#' @param v a vector of integers. If they are not integers they will be
#' 	casted to integers.
#' @return a list with the following items:
#'		\item{values}{unique and sorted values of \code{v}}
#'		\item{map}{a vector such that \code{v[i] = values[map[i]+1]} for every i}
#'	@export
mapToUnique <- function(values) {
    .Call('kfoots_mapToUnique', PACKAGE = 'kfoots', values)
}

subsetM2U <- function(ucs, colidxs) {
    .Call('kfoots_subsetM2U', PACKAGE = 'kfoots', ucs, colidxs)
}

getMultinomConst <- function(counts, nthreads = 1L) {
    .Call('kfoots_getMultinomConst', PACKAGE = 'kfoots', counts, nthreads)
}

getMultinomConstSW <- function(counts, nthreads = 1L) {
    .Call('kfoots_getMultinomConstSW', PACKAGE = 'kfoots', counts, nthreads)
}

sumAt <- function(values, map, size, zeroIdx = FALSE) {
    .Call('kfoots_sumAt', PACKAGE = 'kfoots', values, map, size, zeroIdx)
}

colSumsInt <- function(nums, nthreads = 1L) {
    .Call('kfoots_colSumsInt', PACKAGE = 'kfoots', nums, nthreads)
}

colSumsIntSW <- function(nums, nthreads = 1L) {
    .Call('kfoots_colSumsIntSW', PACKAGE = 'kfoots', nums, nthreads)
}

colSumsDouble <- function(nums, nthreads = 1L) {
    .Call('kfoots_colSumsDouble', PACKAGE = 'kfoots', nums, nthreads)
}

rowSumsDouble <- function(mat, nthreads = 1L) {
    .Call('kfoots_rowSumsDouble', PACKAGE = 'kfoots', mat, nthreads)
}

lLikMat <- function(counts, models, ucs, mConst, lliks, nthreads = 1L) {
    invisible(.Call('kfoots_lLikMat', PACKAGE = 'kfoots', counts, models, ucs, mConst, lliks, nthreads))
}

lLikGapMat <- function(counts, models, ucs, mConst, lliks, nthreads = 1L) {
    invisible(.Call('kfoots_lLikGapMat', PACKAGE = 'kfoots', counts, models, ucs, mConst, lliks, nthreads))
}

pwhichmax <- function(posteriors, nthreads = 1L) {
    .Call('kfoots_pwhichmax', PACKAGE = 'kfoots', posteriors, nthreads)
}

fitNB_inner <- function(counts, posteriors, initR = -1) {
    .Call('kfoots_fitNB_inner', PACKAGE = 'kfoots', counts, posteriors, initR)
}

fitModels <- function(counts, posteriors, models, ucs, nthreads = 1L) {
    .Call('kfoots_fitModels', PACKAGE = 'kfoots', counts, posteriors, models, ucs, nthreads)
}

fitModelsGapMat <- function(counts, posteriors, models, ucs, nthreads = 1L) {
    .Call('kfoots_fitModelsGapMat', PACKAGE = 'kfoots', counts, posteriors, models, ucs, nthreads)
}

asGapMat <- function(counts, colset, nrow) {
    .Call('kfoots_asGapMat', PACKAGE = 'kfoots', counts, colset, nrow)
}

zScoreThresh <- function(lliks, z, nthreads = 1L) {
    .Call('kfoots_zScoreThresh', PACKAGE = 'kfoots', lliks, z, nthreads)
}

fitModelFromColumns <- function(gapmat, model, ucs, negstrand = 0L, nthreads = 1L) {
    .Call('kfoots_fitModelFromColumns', PACKAGE = 'kfoots', gapmat, model, ucs, negstrand, nthreads)
}

filter <- function(cols, scores, thresh, overlap) {
    .Call('kfoots_filter', PACKAGE = 'kfoots', cols, scores, thresh, overlap)
}

